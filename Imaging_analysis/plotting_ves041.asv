
%% function
function plotting_ves041(daq, ts, jump, savepath)

close all

% menotaxis code
%[daq, triggerIdx, rho, Meno_chunks, not_Meno_chunks,ts_rm] = SegmentMenovsNotMeno_2p(daq, savepath, 10, 5,0.88,0.88);

%% benhamou_sinuosity(x, y)
% tuen x and y into columns
x = daq.px';
y =daq.py';
x_supp = daq.px_supp';
y_supp =daq.py_supp';
S = benhamou_sinuosity(x, y);
S_supp = benhamou_sinuosity(x_supp, y_supp);
S_quarters = benhamou_sinuosity(x, y, true);
S_quarters_supp = benhamou_sinuosity(x_supp, y_supp, true);
px = daq.px(:);
py = daq.py(:);
N = numel(px);

% Quarters splitting
quarters = round(linspace(1, N+1, 5)); % Edges for the 4 quarters

% Choose 4 colors (default lines)
colrs = lines(4);

figure; hold on;
legtxt = cell(1,4);
for q = 1:4
    idx = quarters(q):(quarters(q+1)-1);
    plot(px(idx), py(idx), '-', 'Color', colrs(q,:), 'LineWidth', 2);
    % Prepare legend text
    legtxt{q} = sprintf('Q%d: S = %.2f', q, S_quarters(q));
    % Annotate the middle of the segment
    mididx = idx(1) + floor(numel(idx)/2);
    text(px(mididx), py(mididx), sprintf('%.2f', S_quarters(q)), ...
         'Color', colrs(q,:), 'FontWeight','bold', 'FontSize', 10, 'VerticalAlignment','bottom');
end

xlabel('x'); ylabel('y'); axis equal
legend(legtxt,'Location','best');
title(['Trajectory split in quarters (whole S = ' sprintf('%.2f', S) ')']);

% Also display the S value in top-right corner
xl = xlim; yl = ylim;
text(xl(2), yl(2), sprintf('S = %.2f', S), ...
    'HorizontalAlignment', 'right', 'VerticalAlignment', 'top', ...
    'FontWeight', 'bold', 'FontSize', 12, 'BackgroundColor', 'w', 'EdgeColor', 'k');

hold off;

save_plot_with_title_as_filename('benhamou_sinuosity', 'x_y', savepath);
%% define variables
time = daq.t;                  % Time points
dff = ts{1, 1}(1,:);                    % Example dFF data
time_kin = daq.t_supp;        
fwd = daq.bfv; % Example forward velocity data
rot = daq.byv_deg; % Example rotational velocity data
side = daq.bsv_deg;
sample_rate = 1/(max(daq.t)/length(daq.t)); %samples per second

%% all 3 (fwd, rot, dff) on one plot
% Create the figure and subplots
figure;

% Subplot 1: dFF
subplot(3, 1, 1);  % First subplot
hold on
plot(time, dff, 'b', 'LineWidth', 1.5);  % Plot dFF in red
xlabel('Time (s)');
ylabel('dF/F');
title('dF/F');
grid on;

% Subplot 2: Forward Velocity
subplot(3, 1, 2);  % Second subplot
plot(time, fwd, 'black', 'LineWidth', 1.5);  % Plot forward velocity in green
xlabel('Time (s)');
ylabel('Forward Velocity (mm/s)');
title('Forward Velocity');
grid on;
ylim([-5 20]);

% Subplot 3: Rotational Velocity
subplot(3, 1, 3);  % Third subplot
plot(time, rot, 'r', 'LineWidth', 1.5);  % Plot rotational velocity in blue
xlabel('Time (s)');
ylabel('Rotational Velocity (deg/s)');
title('Rotational Velocity');
grid on;
ylim([-500 500]);

% Link the x-axes of all subplots
linkaxes(findall(gcf, 'Type', 'axes'), 'x');

% Add overall labels
sgtitle('dF/F, Forward, and Rotational Velocity');  % Super title

save_plot_with_title_as_filename('fwd_rot', 'dff_separate', savepath);

%% flat path colored by dff (dots with non-linear scaling)
cmap = jet(100);

% Non-linear scaling options for dff (choose one):
% Option 1: Square root scaling (compresses high values)
dff_scaled = sqrt((dff - min(dff)) / (max(dff) - min(dff)));

% Option 2: Logarithmic scaling (for positive values)
% dff_scaled = log((dff - min(dff) + 1)) / log(max(dff) - min(dff) + 1);

% Option 3: Power scaling (enhances small differences)
% dff_scaled = ((dff - min(dff)) / (max(dff) - min(dff))).^0.5;

% Option 4: Sigmoid scaling (S-curve)
% dff_norm_temp = (dff - min(dff)) / (max(dff) - min(dff));
% dff_scaled = 1 ./ (1 + exp(-10 * (dff_norm_temp - 0.5)));

% Convert scaled values to colormap indices
dff_norm = round(dff_scaled * (length(cmap) - 1)) + 1;

figure
hold on

% Plot as scatter points instead of lines
scatter(daq.px, daq.py, 10, cmap(dff_norm, :), 'filled', 'MarkerEdgeColor', 'none');

% Alternative: Plot as individual dots with plot()
% for i = 1:length(daq.px)
%     plot(daq.px(i), daq.py(i), '.', 'Color', cmap(dff_norm(i), :), 'MarkerSize', 15)
% end

% Create colorbar with actual DFF values
c = colorbar;
caxis([1 100])  % Set colorbar limits to match normalized range
yticks = get(c, 'YTick');  % Get current tick positions

% Convert normalized values back to actual DFF values using inverse transformation
% For square root scaling:
actual_scaled = (yticks - 1) / 99;  % Convert back to 0-1 range
actual_values = (actual_scaled.^2) * (max(dff) - min(dff)) + min(dff);

% For logarithmic scaling (uncomment if using log scaling):
% actual_scaled = (yticks - 1) / 99;
% actual_values = (exp(actual_scaled * log(max(dff) - min(dff) + 1)) - 1) + min(dff);

ylabel(c, 'DFF')
set(c, 'YTickLabel', arrayfun(@(x) sprintf('%.3f', x), actual_values, 'UniformOutput', false))

% Add jump points
if jump
    plot(daq.px(logical(daq.jump_detected)), ...
         daq.py(logical(daq.jump_detected)), ...
         'm.', 'MarkerSize', 15)  % Adjust color and size as needed
end

% Start point
plot(daq.px(1), daq.py(1), 'r.', 'MarkerSize', 20)

title("DFF colored (non-linear), cue flat path - dots")
save_plot_with_title_as_filename('x_color', 'y_color', savepath);
%% now interactively plot dff and yaw velocity
trajectory_region_selector(daq, ts{1}, jump)

%% aligned to motion on plotting dff, forward vel, rot vel (all aligned)
preN = round(sample_rate);
offN = 0;
min_run_len = 2*round(sample_rate);
motion = daq.motion.moving_or_not(:);
fluo = ts{1,1}(1,:)';
for_vel = daq.bfv(:);
rot_speed = abs(daq.byv_deg(:)); % rotational velocity in degrees/sec
tt = daq.t(:); % your time vector

d = diff([0; motion; 0]);
onsets = find(d == 1);
offsets = find(d == -1) - 1;

move_lengths = offsets - onsets + 1;
move_keep = move_lengths >= min_run_len;
onsets = onsets(move_keep);
offsets = offsets(move_keep);

prev_offsets = [0; offsets(1:end-1)];
still_lengths = onsets - prev_offsets - 1;
still_keep = still_lengths >= min_run_len;

onsets = onsets(still_keep);
offsets = offsets(still_keep);

fluo_cell = {}; forvel_cell = {}; rotvel_cell = {}; t_cell = {};
for i=1:numel(onsets)
    t_start = onsets(i) - preN;
    t_end   = offsets(i) + offN;
    if t_start < 1 || t_end > numel(fluo), continue; end
    idx_epoch = t_start:t_end;
    t_epoch = tt(idx_epoch);
    t_onset = tt(onsets(i));
    t_rel = t_epoch - t_onset;
    fluo_cell{end+1}    = fluo(idx_epoch);
    forvel_cell{end+1}  = for_vel(idx_epoch);
    rotvel_cell{end+1}  = rot_speed(idx_epoch);
    t_cell{end+1}       = t_rel;
end

% Robust dt and restrict to epochs with enough pre samples
dt_median = median(cellfun(@(t) median(diff(t)), t_cell));
t_pre = -preN*dt_median;
bouts_with_all_pre = cellfun(@(t) any(t <= t_pre), t_cell);
fluo_cell    = fluo_cell(bouts_with_all_pre);
forvel_cell  = forvel_cell(bouts_with_all_pre);
rotvel_cell  = rotvel_cell(bouts_with_all_pre);
t_cell       = t_cell(bouts_with_all_pre);

% Mean axis: overlapping duration only
t_post_max = min(cellfun(@(t) max(t), t_cell));
t_mean = t_pre:dt_median:t_post_max;

% Interpolate all epochs to t_mean for averaging
fluo_mat    = nan(length(t_mean), numel(fluo_cell));
forvel_mat  = nan(length(t_mean), numel(forvel_cell));
rotvel_mat  = nan(length(t_mean), numel(rotvel_cell));
for i = 1:numel(fluo_cell)
    fluo_mat(:,i)   = interp1(t_cell{i}, fluo_cell{i}, t_mean, 'linear', nan);
    forvel_mat(:,i) = interp1(t_cell{i}, forvel_cell{i}, t_mean, 'linear', nan);
    rotvel_mat(:,i) = interp1(t_cell{i}, rotvel_cell{i}, t_mean, 'linear', nan);
end

% ---- Plot all runs (variable) and mean (fixed axis) ----
figure;

% DFF
subplot(3,1,1); hold on;
for i = 1:numel(fluo_cell)
    plot(t_cell{i}, fluo_cell{i}, 'Color', [0.2549 0.4118 0.8824], 'HandleVisibility','off'); % royal blue
end
plot(t_mean, nanmean(fluo_mat,2), 'LineWidth', 2, 'Color', [0 0 0.5451], 'DisplayName', 'Mean'); % dark blue
line([0 0], ylim, 'Color', [0 0 0], 'LineStyle', ':', 'LineWidth', 2);
xlabel('Time from movement onset (s)');
ylabel('DF/F');
title('dF/F aligned to movement onset');
hold off;

% Forward velocity
subplot(3,1,2); hold on;
for i = 1:numel(forvel_cell)
    plot(t_cell{i}, forvel_cell{i}, 'Color', [0.5 0.5 0.5], 'HandleVisibility','off'); % grey
end
plot(t_mean, nanmean(forvel_mat,2), 'Color', [0 0 0], 'LineWidth', 2, 'DisplayName', 'Mean'); % black
line([0 0], ylim, 'Color', [0 0 0], 'LineStyle', ':', 'LineWidth', 2);
xlabel('Time from movement onset (s)');
ylabel('Forward Velocity (mm/s)');
title('Forward Velocity aligned to movement onset');
hold off;

% Rotational velocity (deg/sec)
subplot(3,1,3); hold on;
for i = 1:numel(rotvel_cell)
    plot(t_cell{i}, rotvel_cell{i}, 'Color', [0.7 0 0], 'HandleVisibility','off'); % dark red
end
plot(t_mean, nanmean(rotvel_mat,2), 'Color', [0.3 0 0], 'LineWidth', 2, 'DisplayName', 'Mean'); % darker red
line([0 0], ylim, 'Color', [0 0 0], 'LineStyle', ':', 'LineWidth', 2);
xlabel('Time from movement onset (s)');
ylabel('Rotational Speed (deg/s)');
title('Rotational speed aligned to movement onset');
hold off;

n_epochs = numel(fluo_cell);
subplot(3,1,1); % annotate top plot
yl = ylim; xl = xlim;
text(xl(2), yl(2), sprintf('n epochs = %d', n_epochs), ...
    'HorizontalAlignment', 'right', ...
    'VerticalAlignment', 'top', ...
    'FontSize', 10, 'FontWeight', 'bold', ...
    'BackgroundColor', 'w', 'EdgeColor','k');

save_plot_with_title_as_filename('movement_onset', 'variables', savepath);


%% aligned to motion OFFSET, plotting dff and fwd
preN = 1*round(sample_rate);    % how many samples to show before motion offset
min_run_len = round(sample_rate); % 1 second off
offN = 0;     % set >0 if you want more after next offset

motion = daq.motion.moving_or_not(:);
fluo   = ts{1,1}(1,:)';
for_vel  = daq.bfv(:);
rot_speed  = abs(daq.byv_deg(:));    % <--- rotational velocity in deg/s
tt     = daq.t(:);

% Find all motion on (onsets) and off (offsets)
d = diff([0; motion; 0]);
onsets  = find(d==1);
offsets = find(d==-1)-1;

% Offset refers to when motion turns off (so these are your alignment points)
% Only keep off periods longer than min_run_len
my_onsets = nan(size(offsets)); % next onset after each offset
for i = 1:length(offsets)
    next_on = find(onsets > offsets(i),1,'first');
    if ~isempty(next_on)
        my_onsets(i) = onsets(next_on);
    else
        my_onsets(i) = numel(motion)+1; % i.e. end of data
    end
end

off_lens = my_onsets - offsets;
keep = off_lens >= min_run_len;
offsets = offsets(keep);
my_onsets = my_onsets(keep);

fluo_cell = {}; behav_cell = {}; rot_cell = {}; t_cell = {};

for i = 1:numel(offsets)
    t_start = offsets(i) - preN + 1; % +1 so offset itself is always at same place in vector
    if t_start < 1, continue; end  % skip if not enough pre points
    t_end = my_onsets(i) - 1 + offN; % epoch ends at just before the next movement bout, or can add post points
    t_end = min(t_end,numel(fluo));  % don't run off end
    idx_epoch = t_start:t_end;
    t_offset = tt(offsets(i));
    t_rel = tt(idx_epoch) - t_offset; % time relative to offset (offset=0)
    fluo_cell{end+1}  = fluo(idx_epoch);
    behav_cell{end+1} = for_vel(idx_epoch);
    rot_cell{end+1}   = rot_speed(idx_epoch);
    t_cell{end+1}     = t_rel;
end

% Only keep epochs that have enough pre points and motion off period
len_epoch = cellfun(@length, fluo_cell);
minlen    = min(len_epoch);  % For mean, only use shared window

% Truncate/crop for average
fluo_mat  = nan(minlen, numel(fluo_cell));
behav_mat = nan(minlen, numel(behav_cell));
rot_mat   = nan(minlen, numel(rot_cell));
t_mat     = nan(minlen, numel(fluo_cell));
for i = 1:numel(fluo_cell)
    fluo_mat(:,i)  = fluo_cell{i}(1:minlen);
    behav_mat(:,i) = behav_cell{i}(1:minlen);
    rot_mat(:,i)   = rot_cell{i}(1:minlen);
    t_mat(:,i)     = t_cell{i}(1:minlen);
end
t_mean = mean(t_mat,2,'omitnan');

% Plot
figure;

subplot(3,1,1); hold on;
for i = 1:numel(fluo_cell)
    plot(t_cell{i}, fluo_cell{i}, 'Color', [0.2549 0.4118 0.8824], 'HandleVisibility','off');
end
plot(t_mean, nanmean(fluo_mat,2), 'Color', [0 0 0.5451], 'LineWidth', 2, 'DisplayName', 'Mean');
line([0 0], ylim, 'Color', [0 0 0], 'LineStyle', ':', 'LineWidth', 2);
xlabel('Time from movement offset (s)');
ylabel('DF/F');
title('dF/F aligned to movement offset');
hold off;

subplot(3,1,2); hold on;
for i = 1:numel(behav_cell)
    plot(t_cell{i}, behav_cell{i}, 'Color', [0.5 0.5 0.5], 'HandleVisibility','off');
end
plot(t_mean, nanmean(behav_mat,2), 'k', 'LineWidth', 2, 'DisplayName', 'Mean');
line([0 0], ylim, 'Color', [0 0 0], 'LineStyle', ':', 'LineWidth', 2);
xlabel('Time from movement offset (s)');
ylabel('Forward velocity');
title('Forward velocity aligned to movement offset');
hold off;

subplot(3,1,3); hold on;
for i = 1:numel(rot_cell)
    plot(t_cell{i}, rot_cell{i}, 'Color', [0.7 0 0], 'HandleVisibility','off');
end
plot(t_mean, nanmean(rot_mat,2), 'LineWidth', 2, 'Color', [0.3 0 0], 'DisplayName', 'Mean');
line([0 0], ylim, 'Color', [0 0 0], 'LineStyle', ':', 'LineWidth', 2);
xlabel('Time from movement offset (s)');
ylabel('Rotational Speed (deg/s)');
title('Rotational speed aligned to movement offset');
hold off;

n_epochs = numel(fluo_cell);
subplot(3,1,1);
yl = ylim; xl = xlim;
text(xl(2), yl(2), sprintf('n epochs = %d', n_epochs), ...
    'HorizontalAlignment', 'right', ...
    'VerticalAlignment', 'top', ...
    'FontSize', 10, 'FontWeight', 'bold', ...
    'BackgroundColor', 'w', 'EdgeColor','k');

save_plot_with_title_as_filename('movement_offset', 'variables', savepath);


%% old, more detailed plotting
%% Plot the dff and fwd
% % Plot the dff and fwd
% figure;
% 
% 
% yyaxis left;
% plot(time_kin, fwd, '-b', 'LineWidth', 1.5)% Plot first time series in blue
% ylabel('Forward Velocity');  % Label for the left y-axis
% 
% % Set the y-axis limits for the left axis to [-5, 10]
% ylim([-5 10]);
% 
% % Plot the second time series on the right y-axis
% yyaxis right;
% plot(time, dff, '-r' , 'LineWidth', 1.5);  % Plot second time series in red
% ylabel('dff');  % Label for the right y-axis
% 
% % Add title and x-axis label
% xlabel('Time');
% title('Forward velocity and DFF');
% 
% % Optional: Add legend
% legend('Forward Velocity', 'dff');
% save_plot_with_title_as_filename('Fwd vel', 'dff', savepath);
% 
% %% plot dff and yaw
% figure;
% yyaxis left;
% plot(time_kin, yaw, '-g', 'LineWidth', 1.5);  % Plot first time series in blue
% ylabel('Yaw velocity');  % Label for the left y-axis
% 
% % Set the y-axis limits for the left axis to [-5, 10]
% ylim([-500 500]);
% 
% % Plot the second time series on the right y-axis
% yyaxis right;
% plot(time, dff, '-r', 'LineWidth', 1.5);  % Plot second time series in red
% ylabel('dff');  % Label for the right y-axis
% 
% % Add title and x-axis label
% xlabel('Time');
% title('Yaw velocity and DFF');
% 
% % Optional: Add legend
% legend('yaw velocity', 'dff');
% save_plot_with_title_as_filename('Yaw vel', 'dff', savepath);

%% plot fwd and yaw
% figure;
% yyaxis left;
% plot(time_kin, fwd, '-b');  % Plot first time series in blue
% ylabel('Forward velocity');  % Label for the left y-axis
% 
% % Set the y-axis limits for the left axis to [-5, 10]
% ylim([-5 5]);
% 
% % Plot the second time series on the right y-axis
% yyaxis right;
% plot(time_kin, yaw, '-g');  % Plot second time series in red
% ylabel('yaw vel');  % Label for the right y-axis
% 
% % Add title and x-axis label
% xlabel('Time');
% title('forward and yaw velocity');
% 
% % Optional: Add legend
% legend('fwd velocity', 'yaw velocity');
% save_plot_with_title_as_filename('Fwd vel', 'Yaw vel', savepath);
% 
% 
% %% Plot the side and dff
% % Plot the dff and fwd
% figure;
% yyaxis left;
% plot(time_kin, side, '-y');  % Plot first time series in blue
% ylabel('Sideways velocity');  % Label for the left y-axis
% 
% % Set the y-axis limits for the left axis to [-5, 10]
% ylim([-500 500]);
% 
% % Plot the second time series on the right y-axis
% yyaxis right;
% plot(time, dff, '-r');  % Plot second time series in red
% ylabel('dff');  % Label for the right y-axis
% 
% % Add title and x-axis label
% xlabel('Time');
% title('Side velocity vs dff');
% 
% % Optional: Add legend
% legend('Sideways velocity', 'dff');
% save_plot_with_title_as_filename('Side vel', 'dff', savepath);



%%


%% Parameters
preN = 0; %round(sample_rate);
offN = 0; %round(sample_rate);
min_run_len = 4; %0.5*round(sample_rate);
min_inbetween_len = round(sample_rate);

motion = daq.motion.moving_or_not(:);
fluo = ts{1,1}(1,:)';
for_vel = daq.bfv(:);
rot_speed = abs(daq.byv_deg(:));
tt = daq.t(:);

%% Find bouts
d = diff([0; motion; 0]);
onsets = find(d == 1);
offsets = find(d == -1) - 1;

move_lengths = offsets - onsets + 1;
move_keep = move_lengths >= min_run_len;
onsets = onsets(move_keep);
offsets = offsets(move_keep);

% Compute PRE-still (before each bout)
prev_offsets = [0; offsets(1:end-1)];
pre_still = onsets - prev_offsets - 1;

% Compute POST-still (after each bout)
next_onsets = [onsets(2:end); numel(motion)+1];
post_still = next_onsets - offsets - 1;

% Classification
is_short = (pre_still < min_inbetween_len) & (post_still < min_inbetween_len);
is_long = ~is_short;

groups = {'Long Pre or Post Still', 'Short Pre and Post Still'};
gr_mask = {is_long, is_short};
group_colors = {[0.3 0.5 1], [1 0.4 0.4]}; % blue for long, red for short

%% For each group, collect the bouts
for g = 1:2
    mask = gr_mask{g};
    this_onsets = onsets(mask);
    this_offsets = offsets(mask);

    % -------- ALIGN TO ONSETS --------
    fluo_cell = {}; forvel_cell = {}; rotvel_cell = {}; t_cell = {};
    for i=1:numel(this_onsets)
        t_start = this_onsets(i) - preN;
        t_end   = this_offsets(i) + offN;
        if t_start < 1 || t_end > numel(fluo), continue; end
        idx_epoch = t_start:t_end;
        t_epoch = tt(idx_epoch);
        t_onset = tt(this_onsets(i));
        t_rel = t_epoch - t_onset;
        fluo_cell{end+1}    = fluo(idx_epoch);
        forvel_cell{end+1}  = for_vel(idx_epoch);
        rotvel_cell{end+1}  = rot_speed(idx_epoch);
        t_cell{end+1}       = t_rel;
    end
    % Robust dt and restrict
    dt_median = median(cellfun(@(t) median(diff(t)), t_cell));
    t_pre = -preN*dt_median;
    bouts_with_all_pre = cellfun(@(t) any(t <= t_pre), t_cell);
    fluo_cell    = fluo_cell(bouts_with_all_pre);
    forvel_cell  = forvel_cell(bouts_with_all_pre);
    rotvel_cell  = rotvel_cell(bouts_with_all_pre);
    t_cell       = t_cell(bouts_with_all_pre);

    t_post_max = min(cellfun(@(t) max(t), t_cell));
    t_mean = t_pre:dt_median:t_post_max;
    fluo_mat    = nan(length(t_mean), numel(fluo_cell));
    forvel_mat  = nan(length(t_mean), numel(forvel_cell));
    rotvel_mat  = nan(length(t_mean), numel(rotvel_cell));
    for i = 1:numel(fluo_cell)
        fluo_mat(:,i)   = interp1(t_cell{i}, fluo_cell{i}, t_mean, 'linear', nan);
        forvel_mat(:,i) = interp1(t_cell{i}, forvel_cell{i}, t_mean, 'linear', nan);
        rotvel_mat(:,i) = interp1(t_cell{i}, rotvel_cell{i}, t_mean, 'linear', nan);
    end

    % ----------- PLOT: ALIGNED TO ONSETS -----------
    figure('Name', ['Onset-aligned: ' groups{g}]);
    subplot(3,1,1); hold on;
    for i = 1:numel(fluo_cell)
        plot(t_cell{i}, fluo_cell{i}, 'Color', [group_colors{g}, 0.2], 'HandleVisibility','off');
    end
    plot(t_mean, nanmean(fluo_mat,2), 'LineWidth', 2, 'Color', group_colors{g}, 'DisplayName', 'Mean');
    line([0 0], ylim, 'Color', [0 0 0], 'LineStyle', ':', 'LineWidth', 2);
    xlabel('Time from movement onset (s)');
    ylabel('DF/F');
    title(['dF/F aligned to movement onset (' groups{g} ')']); hold off;

    subplot(3,1,2); hold on;
    for i = 1:numel(forvel_cell)
        plot(t_cell{i}, forvel_cell{i}, 'Color', [0.5 0.5 0.5 0.2], 'HandleVisibility','off');
    end
    plot(t_mean, nanmean(forvel_mat,2), 'Color', [0 0 0], 'LineWidth', 2, 'DisplayName', 'Mean');
    line([0 0], ylim, 'Color', [0 0 0], 'LineStyle', ':', 'LineWidth', 2);
    xlabel('Time from movement onset (s)');
    ylabel('Forward Velocity (mm/s)');
    title('Forward Velocity aligned to movement onset');
    hold off;

    subplot(3,1,3); hold on;
    for i = 1:numel(rotvel_cell)
        plot(t_cell{i}, rotvel_cell{i}, 'Color', [0.7 0 0 0.2], 'HandleVisibility','off');
    end
    plot(t_mean, nanmean(rotvel_mat,2), 'Color', [0.3 0 0], 'LineWidth', 2, 'DisplayName', 'Mean');
    line([0 0], ylim, 'Color', [0 0 0], 'LineStyle', ':', 'LineWidth', 2);
    xlabel('Time from movement onset (s)');
    ylabel('Rotational Speed (deg/s)');
    title('Rotational speed aligned to movement onset');
    hold off;

    n_epochs = numel(fluo_cell);
    subplot(3,1,1);
    yl = ylim; xl = xlim;
    text(xl(2), yl(2), sprintf('n epochs = %d', n_epochs), ...
        'HorizontalAlignment', 'right', ...
        'VerticalAlignment', 'top', ...
        'FontSize', 10, 'FontWeight', 'bold', ...
        'BackgroundColor', 'w', 'EdgeColor','k');
    % --- Place this code after EVERY figure block! ---
    % Define params as strings (for figure title & filename)
    params_str = sprintf('preN=%d, offN=%d, min_run_len=%d, min_inbetween_len=%d, sample_rate=%.2f, group=%s, n=%d', ...
        preN, offN, min_run_len, min_inbetween_len, sample_rate, groups{g}, n_epochs);
    
    % Add as a super-title to the figure 
    sgtitle(params_str, 'FontWeight', 'bold', 'Interpreter', 'none');
    
    % Make a version of group name safe for filename usage:
    safe_group = regexprep(groups{g}, '\W', '_');
    plot_type = get(gcf, 'Name');
    if isempty(plot_type), plot_type = 'plot'; end
    
    % Construct file name
    fname = sprintf('dff_plot_%s_%s_preN%d_offN%d_minrun%d_mininbetween%d_SR%.2f_n%d.png', ...
        plot_type, safe_group, preN, offN, min_run_len, min_inbetween_len, sample_rate, n_epochs);
    
    % Save the figure (as PNG, you can switch to .fig, .pdf, etc as needed)
    save_plot_with_title_as_filename(fname, 'onset', savepath);

    % -------- ALIGN TO OFFSETS --------
    fluo_cell = {}; forvel_cell = {}; rotvel_cell = {}; t_cell = {};
    for i=1:numel(this_offsets)
        t_start = this_onsets(i) - preN;
        t_end   = this_offsets(i) + offN;
        if t_start < 1 || t_end > numel(fluo), continue; end
        idx_epoch = t_start:t_end;
        t_epoch = tt(idx_epoch);
        t_offset = tt(this_offsets(i));
        t_rel = t_epoch - t_offset;
        fluo_cell{end+1}    = fluo(idx_epoch);
        forvel_cell{end+1}  = for_vel(idx_epoch);
        rotvel_cell{end+1}  = rot_speed(idx_epoch);
        t_cell{end+1}       = t_rel;
    end
    % Robust dt and restrict
    dt_median = median(cellfun(@(t) median(diff(t)), t_cell));
    t_pre = -preN*dt_median;
    bouts_with_all_pre = cellfun(@(t) any(t <= t_pre), t_cell);
    fluo_cell    = fluo_cell(bouts_with_all_pre);
    forvel_cell  = forvel_cell(bouts_with_all_pre);
    rotvel_cell  = rotvel_cell(bouts_with_all_pre);
    t_cell       = t_cell(bouts_with_all_pre);

    t_post_max = min(cellfun(@(t) max(t), t_cell));
    t_mean = t_pre:dt_median:t_post_max;
    fluo_mat    = nan(length(t_mean), numel(fluo_cell));
    forvel_mat  = nan(length(t_mean), numel(forvel_cell));
    rotvel_mat  = nan(length(t_mean), numel(rotvel_cell));
    for i = 1:numel(fluo_cell)
        fluo_mat(:,i)   = interp1(t_cell{i}, fluo_cell{i}, t_mean, 'linear', nan);
        forvel_mat(:,i) = interp1(t_cell{i}, forvel_cell{i}, t_mean, 'linear', nan);
        rotvel_mat(:,i) = interp1(t_cell{i}, rotvel_cell{i}, t_mean, 'linear', nan);
    end

    % ----------- PLOT: ALIGNED TO OFFSETS -----------
    figure('Name', ['Offset-aligned: ' groups{g}]);
    subplot(3,1,1); hold on;
    for i = 1:numel(fluo_cell)
        plot(t_cell{i}, fluo_cell{i}, 'Color', [group_colors{g}, 0.2], 'HandleVisibility','off');
    end
    plot(t_mean, nanmean(fluo_mat,2), 'LineWidth', 2, 'Color', group_colors{g}, 'DisplayName', 'Mean');
    line([0 0], ylim, 'Color', [0 0 0], 'LineStyle', ':', 'LineWidth', 2);
    xlabel('Time from movement offset (s)');
    ylabel('DF/F');
    title(['dF/F aligned to movement offset (' groups{g} ')']); hold off;

    subplot(3,1,2); hold on;
    for i = 1:numel(forvel_cell)
        plot(t_cell{i}, forvel_cell{i}, 'Color', [0.5 0.5 0.5 0.2], 'HandleVisibility','off');
    end
    plot(t_mean, nanmean(forvel_mat,2), 'Color', [0 0 0], 'LineWidth', 2, 'DisplayName', 'Mean');
    line([0 0], ylim, 'Color', [0 0 0], 'LineStyle', ':', 'LineWidth', 2);
    xlabel('Time from movement offset (s)');
    ylabel('Forward Velocity (mm/s)');
    title('Forward Velocity aligned to movement offset');
    hold off;

    subplot(3,1,3); hold on;
    for i = 1:numel(rotvel_cell)
        plot(t_cell{i}, rotvel_cell{i}, 'Color', [0.7 0 0 0.2], 'HandleVisibility','off');
    end
    plot(t_mean, nanmean(rotvel_mat,2), 'Color', [0.3 0 0], 'LineWidth', 2, 'DisplayName', 'Mean');
    line([0 0], ylim, 'Color', [0 0 0], 'LineStyle', ':', 'LineWidth', 2);
    xlabel('Time from movement offset (s)');
    ylabel('Rotational Speed (deg/s)');
    title('Rotational speed aligned to movement offset');
    hold off;

    n_epochs = numel(fluo_cell);
    subplot(3,1,1);
    yl = ylim; xl = xlim;
    text(xl(2), yl(2), sprintf('n epochs = %d', n_epochs), ...
        'HorizontalAlignment', 'right', ...
        'VerticalAlignment', 'top', ...
        'FontSize', 10, 'FontWeight', 'bold', ...
        'BackgroundColor', 'w', 'EdgeColor','k');
    % --- Place this code after EVERY figure block! ---
    % Define params as strings (for figure title & filename)
    params_str = sprintf('preN=%d, offN=%d, min_run_len=%d, min_inbetween_len=%d, sample_rate=%.2f, group=%s, n=%d', ...
        preN, offN, min_run_len, min_inbetween_len, sample_rate, groups{g}, n_epochs);
    
    % Add as a super-title to the figure 
    sgtitle(params_str, 'FontWeight', 'bold', 'Interpreter', 'none');
    
    % Make a version of group name safe for filename usage:
    safe_group = regexprep(groups{g}, '\W', '_');
    plot_type = get(gcf, 'Name');
    if isempty(plot_type), plot_type = 'plot'; end
    
    % Construct file name
    fname = sprintf('dff_plot_%s_%s_preN%d_offN%d_minrun%d_mininbetween%d_SR%.2f_n%d.png', ...
        plot_type, safe_group, preN, offN, min_run_len, min_inbetween_len, sample_rate, n_epochs);
    
    % Save the figure (as PNG, you can switch to .fig, .pdf, etc as needed)
    save_plot_with_title_as_filename(fname, 'offset', savepath);
end

%% dff peaks
figure
plot(dff)
findpeaks(dff, ...
    'MinPeakProminence', 3, ...     % Only peaks that "stand out" this height from surroundings
    'MinPeakDistance', 20,    ...     % Min # samples between peaks (e.g. if you want 100 ms separation and fs=100 Hz, use 10)
    'MinPeakHeight', 6,     ...     % Only peaks above certain value
    'Threshold', 1);        % Only peaks that rise at least this above the surrounding troughs


dff = dff(:);        % or: if needed, daq.dff(:)
threshold = 0.8;
dff_slope = [NaN; diff(dff)];  % will be column

mask = dff_slope > threshold;

t = (1:length(dff))';   % make t a column too

figure; hold on;

% RED: where slope > threshold
onsets  = find(diff([0; mask]) == 1);
offsets = find(diff([mask; 0]) == -1);
for i = 1:length(onsets)
    idx = onsets(i):offsets(i)-1;
    plot(t(idx), dff(idx), 'r', 'LineWidth', 2)
end

% BLACK: where slope <= threshold
mask_comp = ~mask;
onsets  = find(diff([0; mask_comp]) == 1);
offsets = find(diff([mask_comp; 0]) == -1);
for i = 1:length(onsets)
    idx = onsets(i):offsets(i)-1;
    plot(t(idx), dff(idx), 'k', 'LineWidth', 2)
end

xlabel('Time');
ylabel('DF/F');
title('dF/F colored where diff(dF/F) > 1.5');
hold off;


%%
%--- Parameters and data (replace variables as needed) ---
fs = sample_rate; % Sample rate in Hz (set this to yours!)
dff = dff(:);
bfv = daq.bfv;
byv = abs(daq.byv_deg);
tt  = daq.t; % Timebase vector

%--- Find events where the slope exceeds threshold ---
thresh = 2.5;
dff_slope = [NaN; diff(dff)];
event_idx = find(dff_slope > thresh);

%--- Extract epochs around each event ---
preS = 1; postS = 2; % Seconds before and after
preN = round(preS * fs);
postN = round(postS * fs);

dff_epochs = {}; bfv_epochs = {}; byv_epochs = {}; t_epochs = {};
for i = 1:length(event_idx)
    idx = event_idx(i);
    i_start = idx - preN;
    i_end   = idx + postN;
    if i_start < 1 || i_end > length(dff), continue, end
    inds = i_start:i_end;
    dff_epochs{end+1} = dff(inds);
    bfv_epochs{end+1} = bfv(inds);
    byv_epochs{end+1} = byv(inds);
    t0 = tt(idx);
    t_epochs{end+1} = tt(inds) - t0;
end

%--- Make mean-aligned axis and matrices for averaging ---
n_epochs = numel(dff_epochs);
if n_epochs == 0
    error('No events found that match criteria!');
end

dt_median = median(cellfun(@(t) median(diff(t)), t_epochs));
t_mean = -preN*dt_median : dt_median : postN*dt_median;
L = length(t_mean);

dff_mat = nan(L, n_epochs);
bfv_mat = nan(L, n_epochs);
byv_mat = nan(L, n_epochs);

for i = 1:n_epochs
    dff_mat(:,i) = interp1(t_epochs{i}, dff_epochs{i}, t_mean, 'linear', nan);
    bfv_mat(:,i) = interp1(t_epochs{i}, bfv_epochs{i}, t_mean, 'linear', nan);
    byv_mat(:,i) = interp1(t_epochs{i}, byv_epochs{i}, t_mean, 'linear', nan);
end

%--- Plot result ---
figure;
subplot(3,1,1); hold on;
for i = 1:n_epochs
    plot(t_epochs{i}, dff_epochs{i}, 'Color', [0.5 0.5 1 0.3], 'HandleVisibility','off');
end
plot(t_mean, nanmean(dff_mat,2), 'b', 'LineWidth',2);
line([0 0], ylim, 'Color','k','LineStyle',':');
xlabel('Time from dF/F slope event (s)'); ylabel('dF/F');
title('dF/F aligned to dF/F slope > 0.8');
hold off;

subplot(3,1,2); hold on;
for i = 1:n_epochs
    plot(t_epochs{i}, bfv_epochs{i}, 'Color', [0.5 0.5 0.5 0.3], 'HandleVisibility','off');
end
plot(t_mean, nanmean(bfv_mat,2), 'k', 'LineWidth',2);
line([0 0], ylim, 'Color','k','LineStyle',':');
xlabel('Time from dF/F slope event (s)'); ylabel('Forward velocity');
title('Forward velocity aligned to dF/F slope > 0.8');
hold off;

subplot(3,1,3); hold on;
for i = 1:n_epochs
    plot(t_epochs{i}, byv_epochs{i}, 'Color', [0.7 0.2 0.2 0.3], 'HandleVisibility','off');
end
plot(t_mean, nanmean(byv_mat,2), 'r', 'LineWidth',2);
line([0 0], ylim, 'Color','k','LineStyle',':');
xlabel('Time from dF/F slope event (s)'); ylabel('Side velocity');
title('Side velocity aligned to dF/F slope > 0.8');
hold off;

sgtitle(sprintf('Alignment to dF/F slope > %.1f, n events = %d', thresh, n_epochs));


end

